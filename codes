#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // For INT_MAX and INT_MIN

// Define the structure for a node in the linked list
struct Node {
    int data;
    struct Node* next;
};

// Global head pointer for the main list
struct Node* head = NULL;

// --- Function Prototypes ---
void createList();
void traverseList(struct Node* startNode);
int countNodes(struct Node* startNode);
void insertAtBeginning();
void insertAtEnd();
void insertAtPosition();
void insertAfterElement();
void deleteFirstNode();
void deleteLastNode();
void deleteAtPosition();
void deleteAfterElement();
void reverseList();
void appendLists();
void findMiddle();
void findMax();
void findMin();
void sortList();


// --- Main Function with Menu ---
int main() {
    int choice;
    printf("--- C Linked List Implementation ---\n");

    // The user must create a list first
    createList();

    while (1) {
        printf("\n\n--------- MENU ---------\n");
        printf("1.  Traverse the list\n");
        printf("2.  Count nodes\n");
        printf("3.  Insert at the beginning\n");
        printf("4.  Insert at the end\n");
        printf("5.  Insert at a specific position\n");
        printf("6.  Insert after a specific element\n");
        printf("7.  Delete the first node\n");
        printf("8.  Delete the last node\n");
        printf("9.  Delete node at a specific position\n");
        printf("10. Delete node after a specific element\n");
        printf("11. Reverse the list\n");
        printf("12. Append another list to the current one\n");
        printf("13. Find the middle element\n");
        printf("14. Find the maximum element\n");
        printf("15. Find the minimum element\n");
        printf("16. Sort the list\n");
        printf("17. Exit\n");
        printf("--------------------------\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                traverseList(head);
                break;
            case 2:
                printf("Total number of nodes: %d\n", countNodes(head));
                break;
            case 3:
                insertAtBeginning();
                break;
            case 4:
                insertAtEnd();
                break;
            case 5:
                insertAtPosition();
                break;
            case 6:
                insertAfterElement();
                break;
            case 7:
                deleteFirstNode();
                break;
            case 8:
                deleteLastNode();
                break;
            case 9:
                deleteAtPosition();
                break;
            case 10:
                deleteAfterElement();
                break;
            case 11:
                reverseList();
                break;
            case 12:
                appendLists();
                break;
            case 13:
                findMiddle();
                break;
            case 14:
                findMax();
                break;
            case 15:
                findMin();
                break;
            case 16:
                sortList();
                break;
            case 17:
                printf("Exiting program. Goodbye!\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }
    return 0;
}


// --- Function Definitions ---

/**
 * 1. Creates a new singly linked list.
 * It will overwrite the existing list if called again.
 */
void createList() {
    int n, data, i;
    struct Node *newNode, *temp;

    // Free the old list if it exists
    while(head != NULL) {
        temp = head;
        head = head->next;
        free(temp);
    }

    printf("\nCreating a new list.\n");
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    if (n <= 0) {
        printf("List creation cancelled as number of nodes is zero or less.\n");
        head = NULL;
        return;
    }

    head = (struct Node*)malloc(sizeof(struct Node));
    if (head == NULL) {
        printf("Unable to allocate memory.");
        return;
    }

    printf("Enter data for node 1: ");
    scanf("%d", &data);
    head->data = data;
    head->next = NULL;
    temp = head;

    for (i = 2; i <= n; i++) {
        newNode = (struct Node*)malloc(sizeof(struct Node));
        if (newNode == NULL) {
            printf("Unable to allocate memory.");
            break;
        }
        printf("Enter data for node %d: ", i);
        scanf("%d", &data);
        newNode->data = data;
        newNode->next = NULL;
        temp->next = newNode;
        temp = temp->next;
    }
    printf("List created successfully.\n");
}


/**
 * 2. Traverses and prints the entire list.
 */
void traverseList(struct Node* startNode) {
    struct Node* temp = startNode;
    if (temp == NULL) {
        printf("List is empty.\n");
        return;
    }
    printf("List elements: ");
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

/**
 * 3. Counts the total number of nodes in the list.
 */
int countNodes(struct Node* startNode) {
    int count = 0;
    struct Node* temp = startNode;
    while (temp != NULL) {
        count++;
        temp = temp->next;
    }
    return count;
}

/**
 * 4. Inserts a new node at the beginning of the list.
 */
void insertAtBeginning() {
    int data;
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Unable to allocate memory.\n");
        return;
    }
    printf("Enter data for the new node: ");
    scanf("%d", &data);
    newNode->data = data;
    newNode->next = head;
    head = newNode;
    printf("Node inserted at the beginning.\n");
    traverseList(head);
}

/**
 * 5. Inserts a new node at the end of the list.
 */
void insertAtEnd() {
    int data;
    struct Node *newNode, *temp;
    newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Unable to allocate memory.\n");
        return;
    }
    printf("Enter data for the new node: ");
    scanf("%d", &data);
    newNode->data = data;
    newNode->next = NULL;

    if (head == NULL) { // If list is empty
        head = newNode;
    } else {
        temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    printf("Node inserted at the end.\n");
    traverseList(head);
}


/**
 * 6. Inserts a node at a specific position (1-based index).
 */
void insertAtPosition() {
    int pos, data, i;
    struct Node *newNode, *temp;

    printf("Enter the position to insert (1-based): ");
    scanf("%d", &pos);

    int totalNodes = countNodes(head);
    // Position 1 is beginning, pos totalNodes+1 is end.
    if (pos < 1 || pos > totalNodes + 1) {
        printf("Invalid position. Please enter a position between 1 and %d.\n", totalNodes + 1);
        return;
    }

    if (pos == 1) {
        insertAtBeginning();
        return;
    }
    
    newNode = (struct Node*)malloc(sizeof(struct Node));
    if(newNode == NULL) {
        printf("Unable to allocate memory.\n");
        return;
    }

    printf("Enter data for the new node: ");
    scanf("%d", &data);
    newNode->data = data;
    
    temp = head;
    // Traverse to the node just before the insertion point
    for (i = 1; i < pos - 1; i++) {
        temp = temp->next;
    }
    
    newNode->next = temp->next;
    temp->next = newNode;

    printf("Node inserted at position %d.\n", pos);
    traverseList(head);
}


/**
 * 7. Inserts a node after a node with a specific value.
 */
void insertAfterElement() {
    int value, data;
    struct Node *newNode, *temp;

    printf("Enter the element value after which to insert: ");
    scanf("%d", &value);
    
    temp = head;
    while(temp != NULL && temp->data != value) {
        temp = temp->next;
    }
    
    if (temp == NULL) {
        printf("Element %d not found in the list.\n", value);
        return;
    }

    newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Unable to allocate memory.\n");
        return;
    }
    
    printf("Enter data for the new node: ");
    scanf("%d", &data);
    newNode->data = data;
    
    newNode->next = temp->next;
    temp->next = newNode;

    printf("Node inserted after element %d.\n", value);
    traverseList(head);
}


/**
 * 8. Deletes the first node of the list.
 */
void deleteFirstNode() {
    if (head == NULL) {
        printf("List is already empty.\n");
        return;
    }
    struct Node* toDelete = head;
    head = head->next;
    free(toDelete);
    printf("First node deleted.\n");
    traverseList(head);
}


/**
 * 9. Deletes the last node of the list.
 */
void deleteLastNode() {
    if (head == NULL) {
        printf("List is already empty.\n");
        return;
    }
    
    struct Node *toDelete, *secondLastNode;
    
    if (head->next == NULL) { // Only one node in the list
        toDelete = head;
        head = NULL;
    } else {
        secondLastNode = head;
        while (secondLastNode->next->next != NULL) {
            secondLastNode = secondLastNode->next;
        }
        toDelete = secondLastNode->next;
        secondLastNode->next = NULL;
    }
    
    free(toDelete);
    printf("Last node deleted.\n");
    traverseList(head);
}


/**
 * 10. Deletes a node from a specific position.
 */
void deleteAtPosition() {
    int pos, i;
    struct Node *toDelete, *prevNode;
    
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    
    printf("Enter position of node to delete (1-based): ");
    scanf("%d", &pos);
    
    int totalNodes = countNodes(head);
    if (pos < 1 || pos > totalNodes) {
        printf("Invalid position. Please enter a position between 1 and %d.\n", totalNodes);
        return;
    }
    
    if (pos == 1) {
        deleteFirstNode();
        return;
    }
    
    prevNode = head;
    for (i = 1; i < pos - 1; i++) {
        prevNode = prevNode->next;
    }
    
    toDelete = prevNode->next;
    prevNode->next = toDelete->next;
    free(toDelete);
    
    printf("Node at position %d deleted.\n", pos);
    traverseList(head);
}


/**
 * 11. Deletes the node present after a certain node value.
 */
void deleteAfterElement() {
    int value;
    struct Node *toDelete, *currentNode;

    if (head == NULL || head->next == NULL) {
        printf("List has less than two nodes, cannot perform this operation.\n");
        return;
    }

    printf("Enter the element value after which to delete: ");
    scanf("%d", &value);

    currentNode = head;
    while (currentNode != NULL && currentNode->data != value) {
        currentNode = currentNode->next;
    }

    if (currentNode == NULL) {
        printf("Element %d not found in the list.\n", value);
    } else if (currentNode->next == NULL) {
        printf("No node exists after element %d to delete.\n", value);
    } else {
        toDelete = currentNode->next;
        currentNode->next = toDelete->next;
        free(toDelete);
        printf("Node after element %d deleted.\n", value);
        traverseList(head);
    }
}


/**
 * 12. Reverses the linked list.
 */
void reverseList() {
    struct Node *prevNode, *currentNode, *nextNode;
    prevNode = NULL;
    currentNode = nextNode = head;

    if (head == NULL) {
        printf("List is empty, cannot reverse.\n");
        return;
    }
    
    while(nextNode != NULL) {
        nextNode = nextNode->next;
        currentNode->next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
    }
    head = prevNode;
    
    printf("List has been reversed.\n");
    traverseList(head);
}


/**
 * 13. Appends a second single linked list to the first one.
 */
void appendLists() {
    struct Node *head2 = NULL, *newNode, *temp, *lastNode;
    int n, data, i;
    
    printf("\n--- Create Second List to Append ---\n");
    printf("Enter the number of nodes for the second list: ");
    scanf("%d", &n);
    
    if (n <= 0) {
        printf("Second list not created. No changes made.\n");
        return;
    }
    
    // Create the head of the second list
    head2 = (struct Node*)malloc(sizeof(struct Node));
    printf("Enter data for node 1 of second list: ");
    scanf("%d", &data);
    head2->data = data;
    head2->next = NULL;
    temp = head2;
    
    // Create the rest of the second list
    for(i = 2; i <= n; i++) {
        newNode = (struct Node*)malloc(sizeof(struct Node));
        printf("Enter data for node %d of second list: ", i);
        scanf("%d", &data);
        newNode->data = data;
        newNode->next = NULL;
        temp->next = newNode;
        temp = temp->next;
    }
    
    printf("Second list created: ");
    traverseList(head2);
    
    // Find the last node of the first list
    if (head == NULL) {
        head = head2;
    } else {
        lastNode = head;
        while(lastNode->next != NULL) {
            lastNode = lastNode->next;
        }
        // Append the second list
        lastNode->next = head2;
    }

    printf("\nLists appended successfully.\n");
    traverseList(head);
}


/**
 * 14. Finds the middle node without counting the total nodes.
 * Uses the slow and fast pointer approach.
 */
void findMiddle() {
    struct Node *slowPtr, *fastPtr;
    slowPtr = fastPtr = head;

    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    
    while(fastPtr != NULL && fastPtr->next != NULL) {
        fastPtr = fastPtr->next->next;
        slowPtr = slowPtr->next;
    }
    
    printf("The middle element is: %d\n", slowPtr->data);
}


/**
 * 15. Finds the maximum value node in the list.
 */
void findMax() {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    
    int max = INT_MIN; // Smallest possible integer
    struct Node* temp = head;
    
    while (temp != NULL) {
        if (temp->data > max) {
            max = temp->data;
        }
        temp = temp->next;
    }
    
    printf("The maximum value in the list is: %d\n", max);
}


/**
 * 16. Finds the minimum value node in the list.
 */
void findMin() {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    int min = INT_MAX; // Largest possible integer
    struct Node* temp = head;
    
    while (temp != NULL) {
        if (temp->data < min) {
            min = temp->data;
        }
        temp = temp->next;
    }
    
    printf("The minimum value in the list is: %d\n", min);
}


/**
 * 17. Sorts the elements of the list in ascending order.
 * Uses bubble sort by swapping data of the nodes.
 */
void sortList() {
    struct Node *current, *index;
    int temp;

    if (head == NULL) {
        printf("List is empty, cannot sort.\n");
        return;
    }

    for (current = head; current->next != NULL; current = current->next) {
        for (index = current->next; index != NULL; index = index->next) {
            if (current->data > index->data) {
                temp = current->data;
                current->data = index->data;
                index->data = temp;
            }
        }
    }
    
    printf("List has been sorted.\n");
    traverseList(head);
}
